# FPGA-ESE2-HAKKI_PENELU
TP FPGA - ESE 2025/26

This repository contains our FPGA lab work using the **DE10-Nano** board and **Intel Quartus Prime Lite** on **Linux**.  
The project follows the progression defined in the FPGA TP instructions, starting from basic Quartus usage to a small graphical project using HDMI.

---

## Environment

- **OS**: Linux (Ubuntu)
- **FPGA board**: DE10-Nano (Cyclone V â€“ 5CSEBA6U23I7)
- **Tools**:
  - Intel Quartus Prime Lite (v25.1)
  - ModelSim (for VHDL simulation)
- **Programming interface**: USB Blaster II  
  > Udev rules were installed to allow USB Blaster access under Linux

---

## TP1 â€“ Quartus Tutorial (Completed)

The first part of the work focused on learning the Quartus workflow:

- Project creation and FPGA selection
- Writing simple VHDL modules
- Pin assignment using Pin Planner
- Compilation and programming of the FPGA

### Implemented features
- LED controlled by a push button
- LED blinking using a clock and counter
- LED toggle using a reset button

âš ï¸ The **LED chain (chenillard)** was not fully functional, but all preliminary steps were successfully validated on hardware.

---

## Petit Projet â€“ Ã‰cran Magique (In Progress)

We are now starting the **Ã‰cran magique** project, which aims to reproduce a digital version of the classic *Etch A Sketch* using:
- HDMI video output
- Two rotary encoders as a digital stylus

### Planned steps
- Encoder management (quadrature signals, direction detection)
- HDMI controller integration
- Pixel positioning using X/Y counters
- Framebuffer memory for pixel persistence
- Screen erase functionality using a push button

Each step follows the same methodology:
1. Design the architecture
2. Implement in VHDL
3. Simulate with ModelSim
4. Test on the FPGA board

---
## Encoder â€“ First Implementation and Clock Issue

At the beginning of the *Ã‰cran magique* project, we modified the `telecran` top-level code to enable the use of the rotary encoder.  
The objective was to detect rising and falling edges on channels **A** and **B** in order to increment or decrement a counter, displayed on the LEDs.

The implementation relies on a classical **edge detection structure**, using two registers per encoder channel to store delayed versions of the input signals. By comparing the current and previous states, both rising and falling edges can be detected synchronously.

However, during testing on the FPGA board, unstable behavior was observed.  
The main issue comes from the system clock frequency (**50 MHz**), which is far too fast compared to the mechanical nature of the encoder. Signal bouncing and oscillations generate multiple unintended transitions, leading to incorrect counting.

This behavior confirms the need to **reduce the effective clock frequency**, using a counter-based clock enable mechanism, as already introduced during the preparation phase. This solution will be implemented in the next step to improve encoder stability and reliability.

---

## RTL View of the Encoder Logic

The following RTL Viewer snapshot confirms the expected hardware structure generated by Quartus:

- Two flip-flops per encoder channel (A and B)
- Combinational logic for rising and falling edge detection
- Adders and multiplexers to increment or decrement the counter
- A register storing the encoder position

![RTL Viewer â€“ Encoder logic](figures/rtl_encoder.png)

---

## Encoder VHDL Implementation (Initial Version)

```vhdl
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

library pll;
use pll.all;

entity telecran is
    port (
        -- FPGA
        i_clk_50 : in std_logic;

        -- HDMI
        io_hdmi_i2c_scl : inout std_logic;
        io_hdmi_i2c_sda : inout std_logic;
        o_hdmi_tx_clk  : out std_logic;
        o_hdmi_tx_d    : out std_logic_vector(23 downto 0);
        o_hdmi_tx_de   : out std_logic;
        o_hdmi_tx_hs   : out std_logic;
        i_hdmi_tx_int  : in std_logic;
        o_hdmi_tx_vs   : out std_logic;

        -- Reset
        i_rst_n : in std_logic;

        -- LEDs
        o_leds : out std_logic_vector(9 downto 0);
        o_de10_leds : out std_logic_vector(7 downto 0);

        -- Encoders
        i_left_ch_a  : in std_logic;
        i_left_ch_b  : in std_logic;
        i_left_pb    : in std_logic;
        i_right_ch_a : in std_logic;
        i_right_ch_b : in std_logic;
        i_right_pb   : in std_logic
    );
end entity telecran;

architecture rtl of telecran is

    signal a_d1, a_d2 : std_logic := '0';
    signal b_d1, b_d2 : std_logic := '0';

    signal a_rise, a_fall : std_logic;
    signal b_rise, b_fall : std_logic;

    signal cnt : unsigned(9 downto 0) := (others => '0');

    signal s_clk_27 : std_logic;
    signal s_rst_n  : std_logic;

begin

    -- Edge detection
    a_rise <= '1' when (a_d1 = '1' and a_d2 = '0') else '0';
    a_fall <= '1' when (a_d1 = '0' and a_d2 = '1') else '0';

    b_rise <= '1' when (b_d1 = '1' and b_d2 = '0') else '0';
    b_fall <= '1' when (b_d1 = '0' and b_d2 = '1') else '0';

    process(i_clk_50, i_rst_n)
    begin
        if (i_rst_n = '0') then
            a_d1 <= '0'; a_d2 <= '0';
            b_d1 <= '0'; b_d2 <= '0';
            cnt  <= (others => '0');

        elsif rising_edge(i_clk_50) then
            a_d1 <= i_left_ch_a;
            a_d2 <= a_d1;
            b_d1 <= i_left_ch_b;
            b_d2 <= b_d1;

            if (a_rise = '1' and b_d1 = '0') or (a_fall = '1' and b_d1 = '1') then
                cnt <= cnt + 1;
            elsif (b_rise = '1' and a_d1 = '0') or (b_fall = '1' and a_d1 = '1') then
                cnt <= cnt - 1;
            end if;
        end if;
    end process;

    -- PLL for HDMI clock
    pll0 : pll
        port map (
            refclk   => i_clk_50,
            rst      => not i_rst_n,
            outclk_0 => s_clk_27,
            locked   => s_rst_n
        );

    -- LED output
    o_leds <= std_logic_vector(cnt);
    o_de10_leds <= (others => '0');

end architecture rtl;

---

## Notes

- Initial configuration issues were encountered on Linux (USB Blaster access), but were resolved.
- All developments follow good VHDL practices:
  - Explicit reset signals
  - Clear naming conventions (`i_`, `o_`, `r_`, `s_`)
- Simulation is strongly preferred before hardware testing to save debugging time.

---

## Status

- âœ… TP1: Quartus tutorial completed  
- ðŸš§ Petit projet: Ã‰cran magique â€“ **ongoing**

---

## Authors

FPGA lab project â€“ ENSEA  
